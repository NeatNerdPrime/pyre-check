(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{162:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(2),i=n(10),a=(n(0),n(173)),o={id:"gradual-typing",title:"Gradual Typing",sidebar_label:"Gradual Typing"},s={id:"gradual-typing",title:"Gradual Typing",description:"The term gradual typing describes a type system where not every expression is typed.",source:"@site/../docs/gradual_typing.md",permalink:"/docs/gradual-typing",sidebar_label:"Gradual Typing",sidebar:"overview",previous:{title:"Configuring Pyre",permalink:"/docs/configuration"},next:{title:"Error Suppression",permalink:"/docs/error-suppression"}},c=[{value:"Strict Mode",id:"strict-mode",children:[]},{value:"Declarative Mode",id:"declarative-mode",children:[]},{value:"Suppressing Specific Errors",id:"suppressing-specific-errors",children:[]},{value:"Stubs",id:"stubs",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The term gradual typing describes a type system where not every expression is typed.\nPyre allows users to explicitly specify how strict the type checking should be on a per-file basis."),Object(a.b)("p",null,"By default, untyped expressions are assumed to be type Any, which is defined as having\nevery attribute and being a sub- and super-type of every other known type.\nThis is useful for annotating functions relying on untyped library code:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  def foo() -> int:\n    return unannotated_library_function() # has type `Any`, which is a subtype of `int`\n")),Object(a.b)("p",null,"There will be no type error in the above code, so we can annotate our function without\nhaving to edit the library function we're using.\nThis can be desirable or necessary, but also gives us very weak guarantees about our code."),Object(a.b)("h2",{id:"strict-mode"},"Strict Mode"),Object(a.b)("p",null,"Pyre supports a strict mode where the above code will no longer type check.\nStrict mode can be enabled by annotating a file with ",Object(a.b)("inlineCode",{parentName:"p"},"# pyre-strict"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  # pyre-strict\n  def foo() -> int:\n    return unannotated_library_function()  # type error: expected `int` but got `Any`\n")),Object(a.b)("p",null,"In case the callee is not under our control we can either suppress the error\n(",Object(a.b)("inlineCode",{parentName:"p"},"# pyre-ignore"),") or create stubs for the library function.\nPyre uses ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/python/typeshed"}),"typeshed"),", a collection of stubs\nfor the standard library originally built to support MyPy.\nPyre also supports custom, repository local stubs."),Object(a.b)("h2",{id:"declarative-mode"},"Declarative Mode"),Object(a.b)("p",null,"In case we're in control of the library function we can now go in and annotate that function too"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  def unannotated_library_function() -> int:\n    return sometimes_returns_a_string(return_string=False)  # uh oh...\n")),Object(a.b)("p",null,"This example is contrived but not unrealistic. Especially when transitioning from a highly dynamic\ncodebase to a statically typed one this happens quite frequently.\nWe could go in, refactor and clean up sometimes_returns_a_string to behave more consistently\nbut more likely than not this will just put us in the same situation over and over again."),Object(a.b)("p",null,"Pyre solves this problem with a per-file declarative mode:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  # pyre-ignore-all-errors\n  def unannotated_library_function() -> int:\n    return sometimes_returns_a_string(return_string=False)  # this is fine\n")),Object(a.b)("p",null,"This tells Pyre to take all annotations at face value (so dependencies type check),\nbut allows us to deal with internal type correctness later."),Object(a.b)("h2",{id:"suppressing-specific-errors"},"Suppressing Specific Errors"),Object(a.b)("p",null,"In some cases we may have a file that will almost meet type-checking save for a few specific kinds\nof dynamic behavior.\nIf we have a file with several of these above kind of incompatible return type errors, we could\nsuppress all of them, but no other kinds of errors with:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  # pyre-ignore-all-errors[7]\n\n  def unannotated_library_function_A() -> int:\n    return sometimes_returns_a_string(return_string=False)  # this is fine\n\n  def unannotated_library_function_B() -> str:\n    return sometimes_returns_a_string(return_string=True)  # this is also fine (in the same file)\n")),Object(a.b)("p",null,"This gives you access to as much static typing as you can handle at a given point."),Object(a.b)("p",null,"However, this should be a stopgap solution, and not a permanent fix.  Suppressing an entire class\nof errors is still pretty dangerous, and over time you should try to converge to full compliance."),Object(a.b)("h2",{id:"stubs"},"Stubs"),Object(a.b)("p",null,"You might have some highly dynamic code that Pyre is having trouble analyzing and\ngetting accurate annotations for - say, ",Object(a.b)("inlineCode",{parentName:"p"},"file.py"),".\nIn this case, you can add a stub ",Object(a.b)("inlineCode",{parentName:"p"},"file.pyi")," in the same directory that contains\nthe annotations for classes & functions, and omit the implementations."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"  # file.py\n  from memoizer import memoize\n\n  class C:\n   cached_fetch = None\n\n  def fetch(self, id):\n    return get_from_network(id)\n\n  C.cached_fetch = memoize(fetch)\n\n  # file.pyi\n  class C:\n    def cached_fetch(self, id: str) -> HttpResponse: ...\n")),Object(a.b)("p",null,"Here, Pyre will ignore the contents of ",Object(a.b)("inlineCode",{parentName:"p"},"file.py"),", and won't know about the existence\nof ",Object(a.b)("inlineCode",{parentName:"p"},"fetch")," and a function that takes an unexpected self argument,\ninstead only seeing the intended signatures."))}u.isMDXComponent=!0},173:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return y}));var r=n(0),i=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,y=p["".concat(o,".").concat(d)]||p[d]||b[d]||a;return n?i.a.createElement(y,s(s({ref:t},l),{},{components:n})):i.a.createElement(y,s({ref:t},l))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);