(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{169:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var r=n(2),a=n(10),o=(n(0),n(171)),i={id:"error-types",title:"Pyre Errors",sidebar_label:"Error Types"},l={id:"error-types",title:"Pyre Errors",description:"Elaboration on some categories of errors thrown by Pyre.",source:"@site/../docs/error_types.md",permalink:"/docs/error-types",sidebar_label:"Error Types",sidebar:"overview",previous:{title:"Error Suppression",permalink:"/docs/error-suppression"},next:{title:"See Pyre Errors In Your Editor",permalink:"/docs/lsp-integration"}},s=[{value:"Pyre Error 9: Incompatible Variable Type",id:"pyre-error-9-incompatible-variable-type",children:[]},{value:"Pyre Errors 14/15: Behavioral Subtyping",id:"pyre-errors-1415-behavioral-subtyping",children:[]},{value:"Pyre Errors 16: Missing Attributes",id:"pyre-errors-16-missing-attributes",children:[{value:"Explicitly Declared",id:"explicitly-declared",children:[]},{value:"Implicitly Declared",id:"implicitly-declared",children:[]}]},{value:"Pyre Errors 18/21: Undefined Name, Undefined Import",id:"pyre-errors-1821-undefined-name-undefined-import",children:[]},{value:"List and Dictionary Mismatches With Subclassing",id:"list-and-dictionary-mismatches-with-subclassing",children:[]},{value:"35: Invalid type variance",id:"35-invalid-type-variance",children:[]},{value:"Pyre Error [56]: Invalid decoration",id:"pyre-error-56-invalid-decoration",children:[{value:"&quot;Pyre was not able to infer the type of the decorator ...&quot;",id:"pyre-was-not-able-to-infer-the-type-of-the-decorator-",children:[]},{value:"&quot;Pyre was not able to infer the type of argument ...&quot;",id:"pyre-was-not-able-to-infer-the-type-of-argument-",children:[]},{value:"&quot;Decorator factory `X` could not be called&quot;",id:"decorator-factory-x-could-not-be-called",children:[]},{value:"&quot;Decorator `X` could not be called&quot;",id:"decorator-x-could-not-be-called",children:[]},{value:"&quot;While applying decorator factory ...&quot;",id:"while-applying-decorator-factory-",children:[]},{value:"&quot;While applying decorator ...&quot;",id:"while-applying-decorator-",children:[]}]}],c={rightToc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Elaboration on some categories of errors thrown by Pyre."),Object(o.b)("h2",{id:"pyre-error-9-incompatible-variable-type"},"Pyre Error ","[9]",": Incompatible Variable Type"),Object(o.b)("p",null,"Pyre will error when assigning incompatible types to local variables and parameters that were explicitly annotated."),Object(o.b)("p",null,"That is, the following will error:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),'def f(x: int) -> None:\n  x = "" # Incompatible variable type error\n  y: int = 1\n  y = "" # Incompatible variable type error\n')),Object(o.b)("p",null,"The rationale here is that it's surprising for an explicitly annotated variable to have an\nincompatible type later on in the same function."),Object(o.b)("p",null,"If you intended to change the type of the variable, you can explicitly annotate it with the new type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),'def f(x: int) -> None:\n  x: str = "" # No errors!\n  y: int = 1\n  y: str = "" # No errors!\n')),Object(o.b)("h2",{id:"pyre-errors-1415-behavioral-subtyping"},"Pyre Errors ","[14/15]",": Behavioral Subtyping"),Object(o.b)("p",null,"Method overrides should follow\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle"}),"Liskov's substitution principle"),".\nIn short, parameter types can't be more restrictive and return types\ncan't be more permissive in overridden methods. To see why, consider the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"  def width(image: Image) -> float:\n    return image.width()\n")),Object(o.b)("p",null,"Say we now have different implementations of our ",Object(o.b)("inlineCode",{parentName:"p"},"Image")," class, one of which\nviolates the substitution principle:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"  class Image:\n    @abstractmethod:\n    def width() -> float: pass\n\n  class JpegImage(Image):\n    @override\n    def width() -> int: return 10  # this is fine\n\n  class ComplexImage(Image):\n    @override\n    def width() -> complex: return 1j\n")),Object(o.b)("p",null,"Clearly our ",Object(o.b)("inlineCode",{parentName:"p"},"width")," function above breaks when used with a ",Object(o.b)("inlineCode",{parentName:"p"},"ComplexImage")," instance.\nThe case for parameters follows analogously."),Object(o.b)("h2",{id:"pyre-errors-16-missing-attributes"},"Pyre Errors ","[16]",": Missing Attributes"),Object(o.b)("p",null,"Your code is most likely trying to access an attribute that Pyre does not know about.\nPyre has various ways of inferring what is an attribute of an object:"),Object(o.b)("h3",{id:"explicitly-declared"},"Explicitly Declared"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"  class Derp:\n    attribute: int = 1\n\n    @property\n    def property(self) -> int: ...\n")),Object(o.b)("h3",{id:"implicitly-declared"},"Implicitly Declared"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"  class Derp:\n    def __init__(self):\n       self.attribute: int = 1\n")),Object(o.b)("p",null,"Pyre does one level of inlining to infer implicit parameters\nWe suggest you do not heavily rely on this feature as it is not sound and makes our code brittle.\nSupport for this is temporary."),Object(o.b)("h2",{id:"pyre-errors-1821-undefined-name-undefined-import"},"Pyre Errors ","[18/21]",": Undefined Name, Undefined Import"),Object(o.b)("p",null,'Error 18 ("Undefined name") is raised when your code tries to access a variable or function that Pyre could not resolve.\nThis is usually caused by failing to import the proper module.'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"  # 'import some_module' is missing\n  some_module.some_func()\n")),Object(o.b)("p",null,'Pyre will raise error 21 instead ("Undefined import") when the import statement is present, but the module to be imported could not be found in the search path.\nIf the module provides stub files, please provide their location via the ',Object(o.b)("inlineCode",{parentName:"p"},"--search-path")," commandline parameter."),Object(o.b)("h2",{id:"list-and-dictionary-mismatches-with-subclassing"},"List and Dictionary Mismatches With Subclassing"),Object(o.b)("p",null,"Pyre will error when, for instance, a ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," is passed in when a ",Object(o.b)("inlineCode",{parentName:"p"},"List[float]")," is expected, as in the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"def to_seconds(milliseconds: List[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Pyre errors here!\n")),Object(o.b)("p",null,"This code is fine at runtime, so it might be surprising that Pyre errors here. However, consider the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"def halve_first_element(list: List[float]) -> None:\n  list[0] /= 2\n\nmy_list: List[int] = [1]\nhalve_first_element(my_list)\nfunction_taking_int(my_list[0]) # Oh no, my_list[0] is 0.5!\n")),Object(o.b)("p",null,"If we allowed passing in ",Object(o.b)("inlineCode",{parentName:"p"},"my_list")," to the ",Object(o.b)("inlineCode",{parentName:"p"},"halve_first_element")," function here, the above code would type check. It's perfectly valid from the perspective of the callee to modify the list's element to be a float, as it was annotated as taking a list of floats, but because this list escapes the scope of the callee, we can't allow this in the type checker."),Object(o.b)("p",null,"To work around this, we can signal to the type checker that the parameter can't be modified. Here's how you can tell the type checker that you won't change the container in your function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"# I can't modify milliseconds here, so it's safe to pass a Iterable[int].\ndef to_seconds(milliseconds: Iterable[float]) -> List[int]:\n  return [int(x/1000.0) for x in milliseconds]\n\nmy_list: List[int] = [1]\nmy_list = to_seconds(my_list) # Type checks!\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"typing.Iterable")," is an immutable variant for lists that allows accessing the list without modifying it. Most commonly used generic containers have immutable variants, and I would encourage you to use them for function parameters whenever you don't need to modify a container in your function.\nHere are some immutable variants for commonly used containers:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"typing.List \u2192 typing.Sequence (if you need random access via my_list[id])\ntyping.List \u2192 typing.Iterable (if you're just iterating over the list in a loop and want to support sets as well)\ntyping.Dict \u2192 typing.Mapping\ntyping.Set \u2192 typing.AbstractSet\n")),Object(o.b)("p",null,"Invariance, combined with type inference, comes with a few gotchas. When you write an expression, Pyre infers the most precise type possible. For instance, Pyre infers the ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," type for ",Object(o.b)("inlineCode",{parentName:"p"},"[1, 2]"),", even though ",Object(o.b)("inlineCode",{parentName:"p"},"List[float]")," would be a perfectly valid type here. This can cause issues, as in the following example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"def zeroes(number_of_elements: int) -> List[float]:\n  a = [0] * number_of_elements\n  return a # Pyre errors here!\n")),Object(o.b)("p",null,"What happened above is that Pyre inferred a type of ",Object(o.b)("inlineCode",{parentName:"p"},"List[int]")," for a, and invariance kicked in. You can work around this by adding an explicit annotation when declaring a:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"def zeroes(number_of_elements: int) -> List[float]:\n  a: List[float] = [0] * number_of_elements\n  return a # Type checks!\n")),Object(o.b)("h2",{id:"35-invalid-type-variance"},"[35]",": Invalid type variance"),Object(o.b)("p",null,"In brief, read-only data types can be covariant, write-only data types can be contravariant, and data types that support both reads and writes must be invariant.\nIf a data type implements any functions accepting parameters of that type, we cannot guarantee that writes are not happening. If a data type implements any functions returning values of that type, we cannot guarantee that reads are not happening.\nFor example (note: int is a subclass of float in the type system and in these examples):\nWrites taking covariants:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),'_T_co = typing.TypeVar("_T_co", covariant=True)\n\nclass MyList(typing.Generic[_T_co]):\n    def write(self, element: _T_co) -> None:\n        ... # adds element to list\n\ndef takes_float_list(float_list: MyList[float]) -> None:\n    float_list.write(1.0)\n\nint_list: MyList[int] = ...\ntakes_float_list(int_list)  # this call is OK because MyList is covariant: MyList[int] < MyList[float]\n# int_list contains floats\n')),Object(o.b)("p",null,"Reads returning contravariants:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),'_T_cont = typing.TypeVar("_T_cont", contravariant=True)\n\nclass MyList(typing.Generic[_T_cont]):\n    def read(self) -> _T_cont:\n        ... # returns first element from list\n\ndef takes_int_list(int_list: MyList[int]) -> int:\n   return int_list.read()\n\nfloat_list: MyList[float] = ...\ntakes_int_list(float_list)  # this call is OK because MyList is contravariant: MyList[float] < MyList[int]\n# problem with return above is clear\n')),Object(o.b)("h2",{id:"pyre-error-56-invalid-decoration"},"Pyre Error ","[","56","]",": Invalid decoration"),Object(o.b)("p",null,"This error code is a catch-all for a variety of problems that can arise in the course of resolving the type of a decorated function.\nIn all of these cases, these decoration failures will lead to the function being registered with type ",Object(o.b)("inlineCode",{parentName:"p"},"Any")," to avoid any spurious downstream errors."),Object(o.b)("h3",{id:"pyre-was-not-able-to-infer-the-type-of-the-decorator-"},'"Pyre was not able to infer the type of the decorator ..."'),Object(o.b)("p",null,"This should only happen when the decorator access itself is invalid, e.g. when you use a decorator which isn't declared in the stubs for a third-party library."),Object(o.b)("h3",{id:"pyre-was-not-able-to-infer-the-type-of-argument-"},'"Pyre was not able to infer the type of argument ..."'),Object(o.b)("p",null,'When using the "decorator factory" pattern, we need to resolve the type of both the decorator factory itself as well as the arguments passed to the decorator factory.\nThis is because the types of these arguments can alter the behavior of the returned decorator via overloads or type variables.\nHowever, this resolution has to happen early in the environment-building pipeline, when we don\'t yet have all of the context we need in order to resolve the types of arbitrary expressions.\nWe support resolving literals and simple globals as arguments, but using anything else will result in this error.'),Object(o.b)("p",null,"To work around this, you can statically type your arguments to the decorator factory as separate globals, which can be validated later in the type-checking pipeline."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'T = TypeVar("T")\ndef decorator_factory(x: T) -> Callable[[Callable[[int], str]], Callable[[str], T]]:\n  ...\n# pyre-fixme[56]: Pyre was not able to infer the type of argument\n#  `complex_expression()` to decorator factory `decorator_factory`.\n@decorator_factory(complex_expression())\ndef foo(x: int) -> str:\n  ...\n\n\nargument: float = complex_expression()\n\n@decorator_factory(argument) # Accepted!  bar resolves to Callable[[str], float]\ndef bar(x: int) -> str:\n  ...\n')),Object(o.b)("h3",{id:"decorator-factory-x-could-not-be-called"},'"Decorator factory ',"`","X","`",' could not be called"'),Object(o.b)("p",null,"This corresponds to when the decorator factory access resolves to a type that is not callable (i.e. has no ",Object(o.b)("inlineCode",{parentName:"p"},"__call__")," method)."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"not_a_factory: int = 5\n\n# pyre-fixme[56]: Decorator factory `not_a_factory` could not be called, because its \n# type `int` is not callable\n@not_a_factory(1)\ndef bar() -> None:\n  pass\n")),Object(o.b)("h3",{id:"decorator-x-could-not-be-called"},'"Decorator ',"`","X","`",' could not be called"'),Object(o.b)("p",null,"Similarly, these errors correspond to when the entire decorator expression (potentially including arguments to a decorator factory), resolves to a non-callable type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def foo() -> int:\n  return 42\n\n# pyre-fixme[56]: Decorator `foo()` could not be called, because its \n# type `int` is not callable\n@foo()\ndef bar() -> None:\n  pass\n")),Object(o.b)("h3",{id:"while-applying-decorator-factory-"},'"While applying decorator factory ..."'),Object(o.b)("p",null,"These errors are emitted from attempting to pass the resolved factory arguments to the factory, as with any other function call."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def factory(x: str) -> Callable[[object], object]: \n  ...\n\n# pyre-fixme[56]: While applying decorator factory `factory`: \n# Expected `str` for 1st param but got `int`.\n@factory(1)\ndef foo() -> None:\n  pass\n")),Object(o.b)("h3",{id:"while-applying-decorator-"},'"While applying decorator ..."'),Object(o.b)("p",null,"Correspondingly, these errors are emitted from trying to pass the decorated function as an argument to the resolved decorator type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"def decorator(f: Callable[[int], str]) -> int:\n  ...\n\n# pyre-fixme[56]: While applying decorator `decorator`:\n# Expected `Callable[[int], str]` for 1st param but got `Callable[[str], int]`.\n@decorator\ndef foo(x: str) -> int:\n  return 5\n")))}p.isMDXComponent=!0},171:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return y}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,y=d["".concat(i,".").concat(u)]||d[u]||b[u]||o;return n?a.a.createElement(y,l(l({ref:t},c),{},{components:n})):a.a.createElement(y,l({ref:t},c))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);